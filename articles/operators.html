<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Operators </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Operators ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/bonsai-rx/docs/blob/main/articles/operators.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="operators">
<h1 id="operators">Operators</h1>

<p>When building a Bonsai program, you chain together reactive operators to create new observable sequences. There are many different operators, which can create all kinds of observable sequences. These operators can be roughly grouped into different categories, depending on their shared characteristics.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Category</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><img src="../images/language-source.svg" alt="Source"></td>
<td>generate event streams from devices or files</td>
</tr>
<tr>
<td style="text-align: center;"><img src="../images/language-transform.svg" alt="Transform"></td>
<td>convert or process individual data items</td>
</tr>
<tr>
<td style="text-align: center;"><img src="../images/language-condition.svg" alt="Condition"></td>
<td>filter data items matching some specific condition</td>
</tr>
<tr>
<td style="text-align: center;"><img src="../images/language-sink.svg" alt="Sink"></td>
<td>save data or trigger external outputs</td>
</tr>
<tr>
<td style="text-align: center;"><img src="../images/language-combinator.svg" alt="Combinator"></td>
<td>manage control flow or synchronize parallel inputs</td>
</tr>
</tbody>
</table>
<h2 id="source">Source</h2>
<p>Sources create sequences that generate notifications spontaneously. This means that you can place these nodes without connecting them to any input. Every Bonsai program will contain at least one source. Usually sources represent streams of data which are acquired from devices or files, such as cameras, microphones, accelerometers, WAV files, network sockets, touchpads, etc.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Even though all sources can be placed independently, sometimes you can still connect an input to them. For example, if you place a <a class="xref" href="../api/Bonsai.Vision.FileCapture.html"><code>FileCapture</code></a> source by itself, it will playback all frames of the movie at the specified frame rate. However, if you connect it to an input, the next frame will be decoded only when a new notification arrives, allowing you to precisely control video playback.</p>
</div>
<h2 id="transform">Transform</h2>
<p>Transforms apply an operation to individual data items in a sequence. They always take exactly one input sequence, and generate another sequence which has the same number of elements as the input, but where each item has been modified according to the function specified by the transform.</p>
<p>In other words, all transforms have a similar style of marble diagram:</p>
<p><img src="../images/marble-transform.svg" alt="Transform operator"></p>
<p>Every transform will always produce exactly one item for every notification generated by the input sequence. Each item that is produced will be the result of applying the transform function on the elements of the input sequence, and is sent out immediately whenever a new notification is received. When the input sequence terminates successfully (or exceptionally), the transformed sequence also terminates.</p>
<p>The only distinction between different transforms will be in the exact function that is applied to each element (e.g., <a class="xref" href="../api/Bonsai.Vision.Grayscale.html"><code>Grayscale</code></a> will convert a sequence of color images to a sequence of grayscale images, while <a class="xref" href="../api/Bonsai.Vision.FindContours.html"><code>FindContours</code></a> will convert a sequence of binary images into a sequence of contours).</p>
<h2 id="condition">Condition</h2>
<p>Condition operators apply a filter on individual data items in a sequence. Similar to transforms, they always take exactly one input sequence, and generate another sequence where the only emitted elements are items from the original sequence that match the condition criteria.</p>
<p><img src="../images/marble-condition.svg" alt="Condition operator"></p>
<p>The condition function is applied to individual items immediately whenever a new notification is received from the input sequence, and valid items are sent out as soon as they are found to match the criteria. When the input sequence terminates successfully (or exceptionally), the filtered sequence also terminates.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The <a class="xref" href="../api/Bonsai.Reactive.Condition.html"><code>Condition</code></a> operator allows you to specify arbitrary matching criteria using a node group. The input to the nested node group is the unfiltered sequence, and the output must be a sequence of elements of type <code>bool</code>, i.e. logical values indicating <code>true</code> or <code>false</code> depending on whether the current item is considered to match the criteria.</p>
</div>
<h2 id="sink">Sink</h2>
<p>Whenever you need to save data into a file, trigger an external output, move a motor, or otherwise generate some kind of side effect with the data processed in Bonsai, you probably need to use a sink operator. Similar to transforms and conditions, sinks also apply a function to every individual element of an observable sequence. However, the application of the function will not modify or filter the input items in any way, which means the output sequence generated by a sink is identical to the input sequence.</p>
<p>For this reason, all sinks also share a very similar style of marble diagram:</p>
<p><img src="../images/marble-sink.svg" alt="Sink operator"></p>
<p>Because the output sequence of a sink is exactly the same as the input sequence, sinks can always be placed at any point of the workflow without breaking existing behaviour.</p>
<div class="NOTE">
<h5>Note</h5>
<p>You can chain multiple sinks sequentially as long as the input is compatible. This can be very convenient when you need to run multiple side effects on a single data stream. A common application is to log data into a file while simultaneously transmitting it to an external device.</p>
</div>
<h2 id="combinator">Combinator</h2>
<p>Although a lot can be done with the right sequence of sources, transforms and sinks, there are many other operators which allow you to express more complex combinations of observables. These operators are grouped together under the <code>Combinator</code> category, but their behaviour can be extremely diverse.</p>
<p>Combinators can be used to merge data from multiple sources; control when observable sequences start and stop; or even to create entirely new sequences dynamically. Together, they provide an incredibly flexible toolkit to manipulate asynchronous data streams.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/bonsai-rx/docs/blob/main/articles/operators.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          &copy; 2024 Bonsai Foundation CIC and Contributors. Licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>. Made with <a href="https://dotnet.github.io/docfx">docfx</a>
        </div>
      </div>
    </footer>
  </body>
</html>
